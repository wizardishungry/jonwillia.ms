---
layout: post
title: "Quick tools.go invocation"
category: featured
tags: [Go]
---
{% include JB/setup %}

[Many](https://www.jvt.me/posts/2022/06/15/go-tools-dependency-management/) places ([including the wiki](https://github.com/golang/go/wiki/Modules#how-can-i-track-tool-dependencies-for-a-module)) recommend managing your CLI tool dependencies with a `tools.go` file. If you haven't seen it before, the TL;DR is: invoke cli utilities (specifically Go commands (`package main`) in other modules) via `go run` (for example `go run github.com/bufbuild/buf/cmd/buf lint`).  Reference the cli utilities in a stub `tools.go` file in the root of your projects:
```go
//go:build tools
// +build tools

package foobar

import (
	_ "github.com/bufbuild/buf/cmd/buf"
	_ "github.com/golangci/golangci-lint/cmd/golangci-lint"
	_ "github.com/mfridman/tparse"
	_ "github.com/twitchtv/twirp/protoc-gen-twirp"
	_ "golang.org/x/vuln/cmd/govulncheck"
	_ "google.golang.org/protobuf/cmd/protoc-gen-go"
)
```
Your command-line utilities will be version using Go modules like everything else in your project, and will benefit from the ecosystem around that (Dependabot, `govulncheck`, etc.).

I've found this helpful as well. **My contribution to this is a bash/zsh function (`gt`) that allows a shorthand invocation of a vendored tool.**

```bash
function gt { go run $(go list -f '{{join .Imports "\n" }}' -tags tools tools.go | egrep "\/$1\$" ) }
```
So now instead of invoking `go run github.com/bufbuild/buf/cmd/buf lint`, you can run `gt buf lint`.<label
for="sn-caveat" class="margin-toggle sidenote-number"></label>
<input id="sn-hogcaveat" class="margin-toggle" type="checkbox">
<span class="sidenote">
This will only work from the root of a Go project where a `tools.go` file exists.
</span>
